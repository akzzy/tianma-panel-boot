name: Fix Poco F1 Touchscreen (Self-Contained)

on:
  workflow_dispatch:
    inputs:
      tianma_boot_url:
        description: 'URL to the NEW Tianma Boot Image (Target)'
        required: true
        default: 'https://images.postmarketos.org/bpo/v25.06/xiaomi-beryllium/phosh/20251212-1422/20251212-1422-postmarketOS-v25.06-phosh-25-xiaomi-beryllium-tianma-boot.img.xz'
      ebbg_boot_url:
        description: 'URL to the EBBG Boot Image (Donor)'
        required: true
        default: 'https://images.postmarketos.org/bpo/v25.06/xiaomi-beryllium/phosh/20251212-1422/20251212-1422-postmarketOS-v25.06-phosh-25-xiaomi-beryllium-ebbg-boot.img.xz'

jobs:
  patch_kernel:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y device-tree-compiler python3 python3-pip wget xz-utils
          pip3 install --upgrade pip

      - name: Setup Tools (Magiskboot & Create Extractor)
        run: |
          mkdir tools
          
          # 1. Download Magiskboot (Verified Working Link)
          wget https://raw.githubusercontent.com/alitekin2fx/magiskboot/master/magiskboot -O tools/magiskboot
          chmod +x tools/magiskboot
          
          # 2. CREATE extract-dtb.py LOCALLY (No external download)
          cat << 'EOF' > tools/extract-dtb.py
          import sys
          import struct
          import os

          def extract(img_path, out_dir):
              if not os.path.exists(out_dir):
                  os.makedirs(out_dir)
              
              with open(img_path, 'rb') as f:
                  data = f.read()

              # DTB Magic Header: D0 0D FE ED (Big Endian)
              magic = b'\xd0\x0d\xfe\xed'
              offset = 0
              count = 0
              found_any = False
              
              while True:
                  offset = data.find(magic, offset)
                  if offset == -1:
                      break
                  
                  # Read total size from header (offset + 4, 4 bytes, big endian)
                  # If file is too short to contain size, break
                  if offset + 8 > len(data): 
                      break
                      
                  size = struct.unpack('>I', data[offset+4:offset+8])[0]
                  
                  # Sanity check on size
                  if size <= 0 or offset + size > len(data):
                      offset += 4 # Move forward slightly to avoid stuck loop if false positive
                      continue

                  with open(f'{out_dir}/{count:02d}.dtb', 'wb') as out:
                      out.write(data[offset:offset+size])
                  
                  print(f'Extracted dtb {count:02d} at offset {offset}, size {size}')
                  offset += size
                  count += 1
                  found_any = True

              if not found_any:
                  print("No DTBs found in file.")

          if __name__ == "__main__":
              if len(sys.argv) < 3:
                  print("Usage: python3 extract-dtb.py <input_file> -o <output_dir>")
                  sys.exit(1)
              extract(sys.argv[1], sys.argv[3])
          EOF

      - name: Download and Extract Boot Images
        run: |
          wget "${{ github.event.inputs.tianma_boot_url }}" -O tianma.img.xz
          wget "${{ github.event.inputs.ebbg_boot_url }}" -O ebbg.img.xz
          unxz -f tianma.img.xz
          unxz -f ebbg.img.xz

      - name: Unpack Images (Magiskboot)
        run: |
          mkdir ebbg_work tianma_work
          
          # Unpack EBBG
          cp ebbg.img ebbg_work/boot.img
          cd ebbg_work
          ../tools/magiskboot unpack boot.img
          cd ..
          
          # Unpack Tianma
          cp tianma.img tianma_work/boot.img
          cd tianma_work
          ../tools/magiskboot unpack boot.img
          cd ..

      - name: Extract and Decompile DTBs
        run: |
          mkdir ebbg_dtbs tianma_dtbs
          
          # Helper to find where DTBs are (sometimes 'dtb' file, sometimes inside 'kernel')
          find_source_file() {
             dir=$1
             if [ -f "$dir/dtb" ]; then echo "$dir/dtb"; else echo "$dir/kernel"; fi
          }
          
          EBBG_SRC=$(find_source_file ebbg_work)
          TIANMA_SRC=$(find_source_file tianma_work)
          
          echo "Source for EBBG DTBs: $EBBG_SRC"
          echo "Source for Tianma DTBs: $TIANMA_SRC"
          
          python3 tools/extract-dtb.py "$EBBG_SRC" -o ebbg_dtbs
          python3 tools/extract-dtb.py "$TIANMA_SRC" -o tianma_dtbs
          
          # Decompile .dtb -> .dts
          for f in ebbg_dtbs/*.dtb; do dtc -I dtb -O dts "$f" -o "${f}.dts"; done
          for f in tianma_dtbs/*.dtb; do dtc -I dtb -O dts "$f" -o "${f}.dts"; done

      - name: Patch DTS (Python Script)
        shell: python3 {0}
        run: |
          import os
          import re
          import sys

          def read_file(path):
              with open(path, 'r') as f: return f.read()

          def write_file(path, content):
              with open(path, 'w') as f: f.write(content)

          def extract_node(content, node_name):
              pattern = re.compile(rf'({node_name}\s*\{{)')
              match = pattern.search(content)
              if not match: return None
              
              start_idx = match.start()
              brace_count = 0
              found_start = False
              
              for i, char in enumerate(content[start_idx:], start=start_idx):
                  if char == '{':
                      brace_count += 1
                      found_start = True
                  elif char == '}':
                      brace_count -= 1
                  
                  if found_start and brace_count == 0:
                      return content[start_idx:i+1]
              return None

          print("--- STARTING PATCH ---")

          # 1. Get Donor Node from EBBG
          ebbg_dir = "ebbg_dtbs"
          source_node = None
          
          for f in os.listdir(ebbg_dir):
              if f.endswith(".dts"):
                  c = read_file(os.path.join(ebbg_dir, f))
                  node = extract_node(c, "touchscreen@38")
                  if node:
                      print(f"Found donor node in {f}")
                      source_node = node
                      break
          
          if not source_node:
              print("ERROR: touchscreen@38 not found in EBBG.")
              sys.exit(1)

          # 2. Replace Target Node in Tianma
          tianma_dir = "tianma_dtbs"
          patched = False
          
          for f in os.listdir(tianma_dir):
              if f.endswith(".dts"):
                  path = os.path.join(tianma_dir, f)
                  c = read_file(path)
                  target = extract_node(c, "touchscreen@1")
                  
                  if target:
                      print(f"Patching {f}...")
                      write_file(path, c.replace(target, source_node))
                      patched = True
                      break
          
          if not patched:
              print("ERROR: touchscreen@1 not found in Tianma.")
              sys.exit(1)
          
          print("--- PATCH COMPLETE ---")

      - name: Recompile and Repack
        run: |
          # 1. Compile modified DTS back to DTB
          for f in tianma_dtbs/*.dts; do 
            dtc -I dts -O dtb "$f" -o "${f%.dts}"; 
          done
          
          # 2. Concatenate DTBs into a single file named 'dtb'
          # Important: We sort them to ensure same order as extracted
          cat $(ls tianma_dtbs/*.dtb | sort) > tianma_work/dtb
          
          # 3. Clean kernel (optional/safety)
          # If the DTBs were originally in 'kernel', magiskboot is usually smart enough
          # to see the new 'dtb' file in the folder and prefer it, 
          # but let's be safe. If we extracted from kernel, we should ideally strip kernel.
          # However, magiskboot repack is robust. If 'dtb' exists in folder, it uses it.
          
          cd tianma_work
          ../tools/magiskboot repack boot.img
          
          mv new-boot.img ../fixed_boot.img
          cd ..

      - name: Upload Fixed Boot Image
        uses: actions/upload-artifact@v4
        with:
          name: fixed-poco-f1-boot-image
          path: fixed_boot.img
